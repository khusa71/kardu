Question,Answer,Topic,Difficulty
"What is the difference between '==' and 'is' operators in Python? Provide an example where they give different results.","'==' checks for value equality, while 'is' checks for identity (same object in memory). Example: a = [1, 2, 3] b = [1, 2, 3] print(a == b)  # True (same values) print(a is b)  # False (different objects)","Operators and Comparisons","intermediate"
"How do you create a list comprehension that generates squares of even numbers from 0 to 10?","[x**2 for x in range(11) if x % 2 == 0] This produces [0, 4, 16, 36, 64, 100]","List Comprehensions","intermediate"
"What is the purpose of the *args and **kwargs parameters in Python functions? Show an example.","*args allows a function to accept variable number of positional arguments, **kwargs accepts variable keyword arguments. def example_func(*args, **kwargs):     print(args)    # tuple of positional args     print(kwargs)  # dict of keyword args example_func(1, 2, name='John', age=25)","Function Parameters","intermediate"
"Explain the difference between shallow copy and deep copy in Python. When would you use each?","Shallow copy creates a new object but references to nested objects remain the same. Deep copy creates completely independent copies. import copy original = [[1, 2], [3, 4]] shallow = copy.copy(original)  # or original.copy() deep = copy.deepcopy(original) Use shallow for simple objects, deep when you need complete independence of nested structures.","Object Copying","intermediate"
"What is a Python decorator and how do you create a simple timing decorator?","A decorator is a function that modifies or extends another function's behavior. import time def timing_decorator(func):     def wrapper(*args, **kwargs):         start = time.time()         result = func(*args, **kwargs)         print(f'{func.__name__} took {time.time() - start:.4f} seconds')         return result     return wrapper","Decorators","intermediate"
"How do you handle multiple exceptions in a single try-except block? Show two different approaches.","Approach 1 - Multiple exception types: try:     # code except (ValueError, TypeError) as e:     print(f'Error: {e}')  Approach 2 - Separate handlers: try:     # code except ValueError:     print('Value error occurred') except TypeError:     print('Type error occurred')","Exception Handling","intermediate"
"What is the difference between a class method and a static method in Python? Provide examples.","Class method receives the class as first argument (cls), static method receives no special first argument. class MyClass:     @classmethod     def class_method(cls):         return f'Called on {cls.__name__}'          @staticmethod     def static_method():         return 'No class reference needed'  Class methods can access class attributes, static methods cannot.","Object-Oriented Programming","intermediate"
"How do you create a generator function and what are its advantages over regular functions returning lists?","Generator function uses 'yield' instead of 'return': def fibonacci_gen(n):     a, b = 0, 1     for _ in range(n):         yield a         a, b = b, a + b  Advantages: Memory efficient (lazy evaluation), can handle infinite sequences, values computed on-demand.","Generators","intermediate"
"What is the purpose of the __init__.py file in Python packages and when is it required?","__init__.py marks a directory as a Python package, allowing imports from that directory. In Python 3.3+, it's optional for implicit namespace packages, but still useful for: - Package initialization code - Controlling what gets imported with 'from package import *' - Setting __all__ variable - Backwards compatibility","Python Packages","intermediate"
"How do you implement a context manager using the __enter__ and __exit__ methods?","class FileManager:     def __init__(self, filename, mode):         self.filename = filename         self.mode = mode          def __enter__(self):         self.file = open(self.filename, self.mode)         return self.file          def __exit__(self, exc_type, exc_val, exc_tb):         self.file.close()         return False  # Don't suppress exceptions","Context Managers","intermediate"
[
  {
    "question": "What is the difference between '==' and 'is' operators in Python? Provide an example where they give different results.",
    "answer": "'==' checks for value equality, while 'is' checks for identity (same object in memory). Example:\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b)  # True (same values)\nprint(a is b)  # False (different objects)",
    "topic": "Operators and Comparisons",
    "difficulty": "intermediate"
  },
  {
    "question": "How do you create a list comprehension that generates squares of even numbers from 0 to 10?",
    "answer": "[x**2 for x in range(11) if x % 2 == 0]\nThis produces [0, 4, 16, 36, 64, 100]",
    "topic": "List Comprehensions",
    "difficulty": "intermediate"
  },
  {
    "question": "What is the purpose of the *args and **kwargs parameters in Python functions? Show an example.",
    "answer": "*args allows a function to accept variable number of positional arguments, **kwargs accepts variable keyword arguments.\ndef example_func(*args, **kwargs):\n    print(args)    # tuple of positional args\n    print(kwargs)  # dict of keyword args\nexample_func(1, 2, name='John', age=25)",
    "topic": "Function Parameters",
    "difficulty": "intermediate"
  },
  {
    "question": "Explain the difference between shallow copy and deep copy in Python. When would you use each?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same. Deep copy creates completely independent copies.\nimport copy\noriginal = [[1, 2], [3, 4]]\nshallow = copy.copy(original)  # or original.copy()\ndeep = copy.deepcopy(original)\nUse shallow for simple objects, deep when you need complete independence of nested structures.",
    "topic": "Object Copying",
    "difficulty": "intermediate"
  },
  {
    "question": "What is a Python decorator and how do you create a simple timing decorator?",
    "answer": "A decorator is a function that modifies or extends another function's behavior.\nimport time\ndef timing_decorator(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f'{func.__name__} took {time.time() - start:.4f} seconds')\n        return result\n    return wrapper",
    "topic": "Decorators",
    "difficulty": "intermediate"
  },
  {
    "question": "How do you handle multiple exceptions in a single try-except block? Show two different approaches.",
    "answer": "Approach 1 - Multiple exception types:\ntry:\n    # code\nexcept (ValueError, TypeError) as e:\n    print(f'Error: {e}')\n\nApproach 2 - Separate handlers:\ntry:\n    # code\nexcept ValueError:\n    print('Value error occurred')\nexcept TypeError:\n    print('Type error occurred')",
    "topic": "Exception Handling",
    "difficulty": "intermediate"
  },
  {
    "question": "What is the difference between a class method and a static method in Python? Provide examples.",
    "answer": "Class method receives the class as first argument (cls), static method receives no special first argument.\nclass MyClass:\n    @classmethod\n    def class_method(cls):\n        return f'Called on {cls.__name__}'\n    \n    @staticmethod\n    def static_method():\n        return 'No class reference needed'\n\nClass methods can access class attributes, static methods cannot.",
    "topic": "Object-Oriented Programming",
    "difficulty": "intermediate"
  },
  {
    "question": "How do you create a generator function and what are its advantages over regular functions returning lists?",
    "answer": "Generator function uses 'yield' instead of 'return':\ndef fibonacci_gen(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\nAdvantages: Memory efficient (lazy evaluation), can handle infinite sequences, values computed on-demand.",
    "topic": "Generators",
    "difficulty": "intermediate"
  },
  {
    "question": "What is the purpose of the __init__.py file in Python packages and when is it required?",
    "answer": "__init__.py marks a directory as a Python package, allowing imports from that directory. In Python 3.3+, it's optional for implicit namespace packages, but still useful for:\n- Package initialization code\n- Controlling what gets imported with 'from package import *'\n- Setting __all__ variable\n- Backwards compatibility",
    "topic": "Python Packages",
    "difficulty": "intermediate"
  },
  {
    "question": "How do you implement a context manager using the __enter__ and __exit__ methods?",
    "answer": "class FileManager:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n    \n    def __enter__(self):\n        self.file = open(self.filename, self.mode)\n        return self.file\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.file.close()\n        return False  # Don't suppress exceptions",
    "topic": "Context Managers",
    "difficulty": "intermediate"
  }
]